# 1.3 图类和适配器

BGL 提供的图类型分为两类。第一类是用于在内存中存储图的图类。第二类是图适配器，它们创建图的修改视图或基于其他类型创建 BGL 图接口。

## 1.3.1 图类

BGL 包含两个主要的图类：`adjacency_list`（邻接表）和`adjacency_matrix`（邻接矩阵）。

BGL 主要用于表示图的组件是邻接表（adjacency list）。这个类对传统的邻接表表示法进行了泛化。图由一组顶点表示，每个顶点存储一组出边。顶点和边的实际实现可以根据特定需求有所不同。邻接表类具有多个模板参数：`EdgeList`、`VertexList`、`Directed`、`VertexProperties`、`EdgeProperties` 和 `GraphProperties`。

- `EdgeList` 和 `VertexList` 指定了用于存储图的顶点列表和边列表的类。这些参数允许在遍历速度、插入/删除速度以及内存消耗之间进行权衡。此外，`EdgeList` 参数还决定了是否可以将平行边插入图中。
- `Directed` 参数指定图是有向的、无向的还是双向的。按照惯例，有向图仅提供对出边的访问，而双向图则提供对入边和出边的访问。
- `VertexProperties`、`EdgeProperties` 和 `GraphProperties` 指定了附加到顶点、边以及图本身的属性类型。

邻接表类的完整文档可以在 §14.1.1 找到。

BGL 用于表示密集图（边数 |E| 约等于顶点数 |V| 的平方）的类是邻接矩阵（adjacency matrix）。在邻接矩阵中，对任意边 (u, v) 的访问是高效的（常数时间）。邻接矩阵可以表示有向图和无向图，并提供了附加属性到顶点和边的机制。邻接矩阵类的完整文档可以在 §14.1.2 找到。

请注意，尽管本书中的所有示例使用的图相对较小（以便图的绘制能够适应单页），但 BGL 图类是强健且空间高效的。它们已被用于表示具有数百万个顶点的图。

## 1.3.2 图适配器
BGL 还包括大量的图适配器。第一组类将任何 BGL 图适配为提供新行为的图。

- `reverse_graph` 是一个适配器，它动态地反转有向图的边方向，使得入边像出边一样行为，反之亦然。
- `filtered_graph` 是一个适配器，它创建了一个图的视图，其中两个谓词函数对象控制原始图中的顶点和边是否出现在适配图中，或者是否被隐藏。

BGL 还支持那些不是 BGL 图类的对象和数据结构。这种支持是通过适配器类和重载函数提供的。以下是这些接口的描述。

- `edge_list` 是一个适配器，它将一个边的迭代器范围转换为一个 BGL 图。
- Stanford GraphBase 通过头文件 `boost/graph/stanford_graph.hpp` 中的重载函数提供支持。因此，GraphBase 类型 `Graph*` 满足 BGL 图接口。
- LEDA 是一个流行的面向对象包，包含图数据结构和算法。头文件 `boost/graph/leda_graph.hpp` 中的重载函数允许 LEDA 图类型 `GRAPH<vtype, etype>` 满足 BGL 图接口。
- STL 复合类型 `std::vector<std::list<int>>` 通过头文件 `boost/graph/vector_as_graph.hpp` 中的重载函数被支持为图。

BGL 接口在第 12 章的概念参考中进行了详细描述。每个图类实现了这些概念中的一些（或全部）。邻接表类可以被视为 BGL 图的典型实现（或模型），因为它展示了 BGL 图的所有基本思想和接口。